111  read write 函数原型和参数定义
    ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t
    *offp);
    ssize_t write(struct file *filp, const char __user *buff, size_t count,
    loff_t *offp);
    对于 2 个方法, filp 是文件指针, count 是请求的传输数据大小. buff 参数指
    向持有被写入数据的缓存, 或者放入新数据的空缓存. 最后, offp 是一个指针指
    向一个"long offset type"对象, 它指出用户正在存取的文件位置. 返回值是一
    个"signed size type"; 它的使用在后面讨论.

2   内核空间和用户空间

    read write方法的buff参数是用户空间的指针，因此，他不能被内核代码直接引用
    ；
    但内核中提供了一组函数来实现用户空间和内核空间的数据交换


3   scull_dev 结构. 结构的 quantum 和 qset
    分别代表设备的量子和量子集大小


4   关于最后一个产生fpos
    如果仅仅是简单地读一下设备, 并且所操作的设备没有"偏移"的概念, 比如GPIO口,
    则可以安全地忽略最后一个偏移参数.

    如果设备有"偏移"概念, 比如带有内部buffer的器件,
    在read()/write()的后端实现时必须关注并测试偏移值,
    在实际执行操作前测试它是否越界(没办法, linux是一个混沌的世界),
    并在实际执行读结束后更新偏移值.（在这种情况下忽略偏移值有一个很严格的条
    件，即要求每次读操作都必须一次性地、安全地读出buffer中的所有内容）


5   信号量
    以一个停车场的运作为例。简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入外面的一辆进去，如果又离开两辆，则又可以放入两辆，如此往复
