（1）设备驱动属于Linux内核的部分，编写Linux设备驱动需要有一定的Linux操作系统内核基础；
Linux设备驱动属于内核的一部分，Linux内核的一个模块可以以两种方式被编译和加载：

　　（1）直接编译进Linux内核，随同Linux启动时加载；

　　（2）编译成一个可加载和删除的模块，使用insmod加载（modprobe和insmod命令类似，但依赖于相关的配置文件），rmmod删除。这种方式控制了内核的大小，而模块一旦被插入内核，它就和内核其他部分一样。
33333333333333
Linux设备文件通硬件一一对应，因而对设备的操作可以通过对设备文件操作来实现。而这些操作方式其实就是一些标准的系统调用，如
open()、read()、write()、close()等。

实际上file_operaters
就是把系统调用和驱动程序关联起来的关键性数据结构。这个结构的每一个成员都对应着一个系统调用。
44444444444
当用户进程利用系统调用对设备文件进行读写操作时，这些系统调用通过设备的主设备号和次设备号来确定相应的设备驱动程序，然后读取
file_operations 中相应的函数指针，接着把控制权交给函数，从而完成了Linux
设备驱动程序的工作。简单地概括：编写设备驱动程序的主要工作就是编写子函数,并填充file_operations的各个域。下面将结合具体的例程来介绍开发流程。


555555555
系统调用通过设备文件的主设备号找到相应的设备驱动程序,

liunx driver work principle
这个结构的每一个成员的名字都对应着一个系统调用.用户进程利用系统调用
在对设备文件进行诸如read/write***作时,系统调用通过设备文件的主设备号
找到相应的设备驱动程序,然后读取这个数据结构相应的函数指针,接着把控制
权交给该函数.这是linux的设备驱动程序工作的基本原理

6666666666666666 register the driver module
驱动程序是内核的一部分，因此我们需要给其添加模块初始化函数，该函数用来完成对所控设备的初始化工作，并调用register_chrdev()
函数注册字符设备：
在用insmod命令将编译好的模块调入内存时，init_module
函数被调用。在这里，init_module只做了一件事，就是向系统的字符设备表登记了一个字符设备。register_chrdev需要三个参数，参数一是希望获得的设备号，如果是零的话，系统将选择一个没有被占用的设备号返回。参数二是设备文件名，参数三用来登记驱动程序实际执行操作的函数的指针。如果登记成功，返回设备的主设备号，不成功，返回一个负值。

77777777777777777
open 打开文件，返回的句柄和文件设备号不同；

8888888888888888 liunx driver development process

基于操作系统的驱动就是在无操作系统下的硬件接口函数加上操作系统外套

实现一个嵌入式Linux设备驱动程序的大致流程如下:
(l)查看原理图，理解设备的工作原理。
(2)定义主设备号。设备由一个主设备号和一个次设备号来标识。主设备号唯一标识了设
备类型，即设备驱动程序类型，它是块设备表或字符设备表中设备表项的索引。次设备号仅
由设备驱动程序解释，区分被一个设备驱动控制下的某个独立的设备。
(3)实现初始化函数。在驱动程序中实现驱动的注册和卸载。
(4)设计所要实现的文件操作，定义file--operations结构。
(5)实现所需的文件操作调用，如read，write等。
(6)实现中断服务，并用request--irq向内核注册，中断并不是每个设备驱动所必需的。
(7)编译该驱动程序到内核中，或者用insmod命令加载模块。
(8)测试该设备，编写应用程序，对驱动程序进行测试。

典型字符设备驱动编写框架：

1 编写硬件接口函数

2 建立文件系统与设备驱动程序间的接口，如：struct file_operations结构体

3
注册设备到chrdevfs全局数组中，注册或注销设备可以在任何时候，但一般在模块加载时注册设备，在模块退出时注销设备。（module_init（）；module_exit（）；）

4 以模块方式编译驱动源码，并将其加载到内核中

5 创建设备节点，mknode
6 编写应用程序访问底层设备
